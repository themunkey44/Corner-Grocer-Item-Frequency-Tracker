# Corner-Grocer-Item-Frequency-Tracker
This program implements a Corner Grocer Item Frequency Tracker, which reads a list of grocery items from an input file, counts the frequency of each item, and provides various functionalities through a menu-driven interface. The program allows users to search for the frequency of specific items, display a list of items and their frequencies, and visualize item frequencies using a histogram.

# Summarize the project and what problem it was solving.
This program aimed to read the grocery text records from the client, Corner Grocer, and analyze the number of times items were purchased by customers in a friendly, menu-driven interface that makes it easy for them to retrieve meaningful information. The original data listed items in the order they were purchased, which made it difficult to identify patterns or determine which products were purchased most often. Manually analyzing this information would be time-consuming and error-prone, especially as the amount of data grows.

To solve this problem, the program reads the input file, counts how often each item appears, and presents the results through a clear, menu-driven interface and an output file. Users can search for the frequency of a specific item, view a complete list of all items and their purchase counts, or visualize the data using a text-based histogram. By converting raw transactional data into organized, easy-to-understand output, the program enables the client to better understand customer behavior and make informed decisions about product placement and store layout.

# What did you do particularly well?
One thing that I did particularly well was maintaining clear, consistent comments and explanations throughout the code while keeping the overall structure organized and easy to follow.

Another thing I did well was following good coding practices, including keeping main() abstract and straightforward, maintaining a clear class structure, and separating responsibilities between classes and the programâ€™s standalone functions. The ItemList class focuses entirely on managing data and operations related to items and their frequencies, while the functions outside the class handle user interaction, menu logic, and program flow. This separation made the program easier to reason about and understand, and it eliminated the need for an unnecessary driver class that does nothing else. 

Finally, I did a good job of incorporating error handling and validation early in the design rather than treating it as an afterthought. This helped make the program more robust and resistant to invalid input or unexpected file-related issues. Since error handling was deliberately built into the application, the final program is more stable, easier to debug, and less likely to fail unexpectedly or act unpredictably when faced with invalid input.

# Which pieces of the code did you find most challenging to write, and how did you overcome this? What tools or resources are you adding to your support network?
I found validating user input and handling errors, including edge cases and incorrect inputs, to be the most difficult part of the project. As part of the design, I wanted to ensure that no matter what the user entered, it would not be possible for them to crash or break the program. However, implementing this cleanly required careful thought. However, I faced several challenges when implementing this.

One challenge was handling incorrect file names and file-related errors, such as attempting to open a file that does not exist or cannot be read. This was difficult because the function that reads items from the file exists inside the ItemList class, while the logic for prompting the user and responding to errors exists outside the class. To solve this, I used exceptions in the class methods and handled those exceptions in the handleFileIO() function, which allowed the program to request a new filename instead of terminating abruptly. I could have handled errors entirely inside the ItemList class, but doing so would have tightly coupled user interaction logic to the data-processing class. Keeping error handling outside the class ensures errors are handled flexibly and consistently, makes the code clearer and easier to understand, and allows the file-reading logic to be reused in other programs without modification.

Another challenge with this was verifying menu inputs. I did this using a char with a switch statement, but if a user entered a string, like "message", then the menu would print the error message and menu options once per character in the string, when ideally we would only have it output the message once and then allow the user to enter a new input to try. After more research into input and output streams, I eventually stumbled upon the std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n') command, which clears the remaining characters from the input buffer. This allowed the program to discard invalid input cleanly and request new input from the user. This solved almost all of my varificaiton problems, with the only edge case remaining in the problem being that if a user enters a sting that starts with a valid menu option, such as "2text4", it would execute the memu option it starts with, in this example, menu option 2, and then clear the rest of the string out like in the error case. Ideally, such a string should also trigger an error message, but that requires much more complicated parsing than I found was necessary, and also allows this to select a menu option, allowing for mispressed keys like "2w" to still generate the intended menu response, and so I decided that the error handling I have, which prevents any other input from casuing issues, is good enough.

A final input challenge has to do with the item names themselves. I wanted to support multi-word item names, such as "red peppers", and so I needed to find a way to extract the entire name, account for whitespaces and other formatting issues, and then add the item to the list. I knew I was able to get the entire line with getline(), but I was particularly concerned about cases where a single space, tab, or other whitespace character would cause the program to think that two items are different. For example, "Lettice" and "Lettice " would be considered different if looking at them character by character due to the additional space, so I needed a way to reliably remove whitespace around input items. In a previous project, i had a functon that looped over all chars in a string and created a new string with only non-whitespace chars, which i used with cin >> var to ensure that only one word was entered at a time with no whitespace whatsoever. However, this would not work in this case since I wanted to support multi-word item names. To make this work, I had to research string formatting functions and charcitors, and eventually learned about find_first_not_of() and find_last_not_of(), which allowed me to trim leading and trailing whitespace reliably without removing spaces between words. This greatly improved the verification of user inputs and taught me something that I had not known before. 

# Where could you enhance your code? How would these improvements make your code more efficient, secure, and so on?
There are several ways this code could be enhanced. While the program handles input well, it is not completely foolproof. For example, item names with multiple spaces between words (such as "Red Peppers") are still treated differently from "Red Peppers". Additionally, capitalization is not normalized, so "red peppers", "Red peppers", and "Red Peppers" are all considered distinct items. Ideally, the program would normalize spacing and capitalization so that logically identical item names are always treated as the same item, regardless of spacing or capitalization. These improvements would make the program more accurate and user-friendly, especially when working with inconsistent real-world data.

Another potential enhancement relates to scalability. Currently, the program processes a single input file at a time. If the client wanted to analyze data from multiple days or registers, the program would need to support merging multiple input files or appending new data to an existing dataset. Adding this functionality would make the program more practical for long-term use. The program also does not currently support correcting or removing invalid data once it has been loaded. Although input validation minimizes this risk, adding functionality to edit or remove items would improve data integrity and allow administrators to correct mistakes without rerunning the program from scratch. 

Finally, I am uncertain about how this program would handle enormous datasets, so more experimentation and improvements on file-reading efficiency, data formatting, and storage considerations should be explored and implemented to handle the (often) large datasets of grocery stores. 

# What skills from this project will be particularly transferable to other projects or coursework?
This project helped me bridge the gap between purely function-based programs and fully object-oriented designs. My earlier projects in C++ tended to lean heavily in one direction or the other, either built around functions or built around classes and methods (as have some other projects in Java), and this project allowed me to experiment with a hybrid approach that combines both styles. This experience showed me how to choose the right abstraction for different parts of a program rather than forcing everything into a single paradigm. In this case, this hybrid approach, where I use a class for core data and logic while keeping some program flow and user interaction elements separate, feels much more practical and scalable. The skills I developed here, such as structuring classes effectively alongside helper functions, handling file I/O, implementing error handling with exceptions, and the various ways of validating user and file input, will be directly transferable to future coursework and more complex software projects. This project especially strengthened my skills in validating user input by assessing edge cases, handling file and input errors safely, and preventing crashes or undefined behavior, all of which will be critical in future coursework and future software development. 

# How did you make this program maintainable, readable, and adaptable?
Besides extensive use of comments to document the code, which makes it easy to understand what the code is doing, I focused on keeping functions and methods short, clearly named, and focused on a single responsibility. I also structured the program so that changes to one part (such as how items are stored or displayed) would not require major changes elsewhere. This made the program easier to debug and reason about. In addition, I made deliberate choices to keep the code adaptable to future changes by avoiding hard-coded assumptions wherever possible. For example, item data is stored in a map rather than a fixed-size structure, which allows the program to scale naturally as the number of items grows. The menu-driven design also makes it straightforward to add new features, such as additional reports or filtering options, without rewriting existing logic. Because the ItemList class exposes only well-defined public methods, internal implementation details can change without affecting the rest of the program.

I also included a method that is not currently used in the program, RemoveItem(), to support future extensibility. While this function was not required for the current assignment, it would allow items to be removed from the list if future requirements changed (for example, updating inventory dynamically or undoing entries). Although the function was initially suggested by the IDE while designing the class, I chose to implement it fully so the class could be more easily extended later without requiring structural changes in case I would need it. For example, if the program were expanded to allow users to remove items (such as to remove faulty data), this function would already be available. Including such forward-looking functionality helps make the program more adaptable and easier to extend without changing existing code.

I also used clear naming conventions and consistent formatting so that another developer (or my future self) could quickly understand the intent of the code without needing to trace every line. Functions are grouped logically, related responsibilities are clearly separated, and error-handling behavior is predictable and centralized. These decisions make the program easier to test, debug, and extend, and they reflect good practices that emphasize making maintainable, readable, and easily understandable code.
